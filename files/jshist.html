<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="generator" content="pandoc"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="An essay about JavaScript"><meta name="author" content="Brian Lennon"><meta name="dcterms.date" content="2018-01-01"><title>JavaScript Affogato: Programming a Culture of Improvised Expertise</title><link rel="stylesheet" href="http://yui.yahooapis.com/combo?pure/0.6.0/base-min.css&pure/0.6.0/grids-responsive-min.css&pure/0.6.0/menus-min.css&pure/0.6.0/tables-min.css"><style>body{margin:1em 0 0}.pure-g{padding:0 1em}.pure-menu-link:focus{background-color:#d3d3d3}nav{margin:0 0 1em;padding:0 0 1em;border-bottom:1px solid #ccc}footer{margin:5em 0 1em}pre{white-space:pre-wrap;margin-left:3em}code{font-size:89%;color:#191919}.author{margin-bottom:0;padding-bottom:0}.headnote,.license,.published{font-size:89%;margin-bottom:.75em}@media screen and (max-width:35.5em){thead{display:none}td,th,tr{display:block}td{border-top:0}tr td:first-child{border-top:1px solid #ddd;font-weight:700}}</style><style>a.sourceLine{display:inline-block;line-height:1.25}a.sourceLine{pointer-events:none;color:inherit;text-decoration:inherit}a.sourceLine:empty{height:1.2em;position:absolute}.sourceCode{overflow:visible}code.sourceCode{white-space:pre;position:relative}div.sourceCode{margin:1em 0}pre.sourceCode{margin:0}@media screen{div.sourceCode{overflow:auto}}@media print{code.sourceCode{white-space:pre-wrap}a.sourceLine{text-indent:-1em;padding-left:1em}}pre.numberSource a.sourceLine{position:relative}pre.numberSource a.sourceLine:empty{position:absolute}pre.numberSource a.sourceLine::before{content:attr(data-line-number);position:absolute;left:-5em;text-align:right;vertical-align:baseline;border:none;pointer-events:all;-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;padding:0 4px;width:4em;color:#aaa}pre.numberSource{margin-left:3em;border-left:1px solid #aaa;padding-left:4px}@media screen{a.sourceLine::before{text-decoration:underline}}code span.al{color:red;font-weight:700}code span.an{color:#60a0b0;font-weight:700;font-style:italic}code span.at{color:#7d9029}code span.bn{color:#40a070}code span.cf{color:#007020;font-weight:700}code span.ch{color:#4070a0}code span.cn{color:#800}code span.co{color:#60a0b0;font-style:italic}code span.cv{color:#60a0b0;font-weight:700;font-style:italic}code span.do{color:#ba2121;font-style:italic}code span.dt{color:#902000}code span.dv{color:#40a070}code span.er{color:red;font-weight:700}code span.fl{color:#40a070}code span.fu{color:#06287e}code span.in{color:#60a0b0;font-weight:700;font-style:italic}code span.kw{color:#007020;font-weight:700}code span.op{color:#666}code span.ot{color:#007020}code span.pp{color:#bc7a00}code span.sc{color:#4070a0}code span.ss{color:#b68}code span.st{color:#4070a0}code span.va{color:#19177c}code span.vs{color:#4070a0}code span.wa{color:#60a0b0;font-weight:700;font-style:italic}</style></head><body><section id="page-content"><div class="pure-g"><div class="pure-u-1 pure-u-sm-1 pure-u-md-1 pure-u-lg-1 pure-u-xl-1"><header><h1 class="title">JavaScript Affogato: Programming a Culture of Improvised Expertise</h1><h2 class="author">Brian Lennon</h2><h3 class="date">2018</h3></header><p><strong>Author’s postprint version</strong>, preceding journal copy editing but otherwise identical to publisher’s PDF.</p><p>Published as: Lennon, Brian. “<a href="http://muse.jhu.edu/article/685007">JavaScript Affogato: Programming a Culture of Improvised Expertise</a>.” <em>Configurations</em> 26.1 (2018): 47–72. © 2018 The Johns Hopkins University Press.</p><section id="abstract" class="level2"><h2>Abstract</h2><p>This essay attempts a philological, meaning a both technically and socially attentive historical study of an individual computer programming language, JavaScript. From its introduction, JavaScript’s reception by software developers, and its importance in web development as we now understand it, was structured by a continuous negotiation of expertise. I use the term “improvised expertise” to describe both conditions for and effects of the unanticipated development of JavaScript, originally designed for casual and inexpert coders, into a complex of technical artifacts and practices whose range and complexity of use has today propelled it into domains previously dominated by other, often older and more prestigious languages. “Improvised expertise” also marks the conditions for and effects of three specific developmental dynamics in JavaScript’s recent history: first, the rapidly accelerated development of the language itself, in the versions of its standard specification; second, the recent, abruptly emerging, yet rapid growth of JavaScript in server-side networking, data processing, and other so-called back end development tasks previously off limits to it; third, the equally recent and abrupt, yet decisive emergence of JavaScript as the dominant language of a new generation of dynamic web application frameworks and the developer toolchains or tooling suites that support them.</p></section><section id="introduction" class="level2"><h2>Introduction</h2><p>2016 was an inconspicuously transitional year for the information space once commonly referred to as The World Wide Web. Those attentive to linguistic usage will recall that the 2016 edition of The Associated Press Stylebook and Briefing on Media Law released in June recommended that the words “internet” and “web” no longer be written with initial capital letters,<span class="citation" data-cites="alba_ap_2016"><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></span> in a sign that the propriety marked by their referents’ novelty had finally settled, or worn off. For those more attuned to matters of technical infrastructure, what may come to mind instead is the announcement by Oracle Corporation that its Java web browser plugin would be deprecated in the forthcoming ninth version of its Java Development Kit (JDK), a platform for writing and packaging software applications in the Java programming language.<span class="citation" data-cites="warren_oracles_2016"><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a></span> Taking these two real, if lesser milestones together, it seems safe to say that for anyone who remembers the original promise made for Java applets as a common WWW technology, at their moment of emergence in the mid-1990s, this was a chapter of recent technological and cultural history quietly coming to an end.<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a></p><p>To be sure, Oracle’s hand had been forced by Microsoft, Google and Apple, who had either reduced Java plugin support in their browser products or removed it entirely. And yet embedded Java applets had long since become a legacy technology, still useful for some computationally intensive graphical visualization tasks (disproportionately in scientific applications), but no longer in wide use outside that domain. Whether or not they are old enough to remember the role originally imagined for Java in the browser, in particular, most of those who design web sites and program web applications for a living today would be unlikely to regret their eclipse. Even before the emergence of personal data security as a substantive public issue in 2012, Java applets presented grave, often intractable security risks that web developers had had to learn how to manage, or ignore. A more general reason for the irrelevance of Java browser applets by 2016 was a historical one, linked to changes in the profile of the Java programming language and Java programmers in the software development industry as a whole. When Fredrick P. Brooks, Jr. chose for the seventh chapter of <em>The Mythical Man-Month: Essays on Software Engineering</em> (1975) the title “Why Did the Tower of Babel Fail?,” he was reflecting on the biblical story of Babel as a fable of engineering (the hubristic or merely presumptuous construction of a tower tall enough to reach heaven), rather than a fable of language (divine punishment imposed in the form of linguistic difference and permanently impaired communication).<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a> Nevertheless, <em>The Mythical Man-Month</em>, the first widely read and still the most celebrated reflection on managing large software projects, was also an informal study of communication, not excluding the metaphorized communication that a software programmer struggles to achieve with a machine.</p><p>The present essay is an essay about the negotiation of technical expertise, specifically the technical expertise involved in software programming, and in particular that involved in programming web sites and applications — that is, what is today called “web development.” I take my bearings from the present historical moment, understood as an interval of continued economic recession (or if one insists, “uneven recovery”) shaped by both economic and political investment in “coding” instruction as job retraining for unemployed and underemployed U.S. blue- and white-collar workers alike. In recent years sociologically oriented cultural studies scholars like Adrian Mackenzie have produced valuable work on cultures of software development, work that is laudable for being simultaneously technically informed and socially focused.<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> While it has been receptive to such research in so-called software studies, scholarship in humanities disciplines has not displayed a proportionate interest in the specifically social and cultural dimensions of the specifically linguistic history of computing, and this is the case especially where individual programming languages and their development and usage cultures are concerned.<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a> The broad exception is, of course, the historiography of computing, and science and technology studies more broadly. But even here, Mark Priestley is surely right to suggest that early, purely technical histories of programming languages have been followed by socially attentive histories of software as a general object and domain, leaving individual languages behind as objects of potentially equally both technically and socially focused study.<span class="citation" data-cites="priestley_science_2010"><a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a></span></p><p>Granting that no duplication of the early, narrow technical histories is necessary — they were meticulous, if unsurprisingly disproportionately anecdotal in character<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a> — how can we describe the humanities research space separating an early historiography of programming languages that is as old as the Fortran, Lisp, Algol, and Cobol languages themselves (which originates, that is to say, in the late 1950s), and recent social histories of the software concept as Martin Campbell-Kelly’s <em>From Airline Reservations to Sonic the Hedgehog: A History of the Software Industry</em> (2004)?<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a> A clue is to be found, I would suggest, in an essay by William Paulson titled “For a Cosmopolitical Philology: Lessons from Science Studies,”<span class="citation" data-cites="paulson_for_2001"><a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a></span> in so far as in that essay, published in 2001, Paulson suggested the value of bringing science and technology studies (STS) scholarship into contact with an older literary humanist tradition of philology: a tradition whose methodologies were globally comparative and multilingual, whose mode was the study of texts in multiple languages (which required intensive study of the languages themselves), and which was rooted in a specific Western intellectual-historical tradition, the tradition of secular or historical humanism. If we set aside this latter tradition (one that STS scholars would surely understand themselves as sharing with “philologists,” that is, with language and literature scholars), philology’s characteristic mode of focus, grounded as it is in the mandates of linguistic specificity, even incommensurability, cannot be described as a great strength or even necessarily a normal characteristic of scholarship in STS.</p><p>From a position close to Paulson’s own, then, one might invite software studies and so-called critical code studies, as well as STS itself, to establish an as-yet imagined contact with philology. What, we might ask, would a philological study — that is, a minimally both technically and socially oriented historiography — of a specific computer programming language look like? For an example of how this question might be posed within the disciplinary context of the information sciences, rather than within that of the humanities (as I shall do here), we can consult recent work like Andrew J. Ko’s “What Is a Programming Language, Really?” “In computing,” Ko remarks, “we usually take a technical view of programming languages (PL), defining them as formal means of specifying a computer behavior. This view shapes much of the research that we do on PL, determining the questions we ask about them, the improvements we make to them, and how we teach people to use them. But to many people, PL are not purely technical things, but <em>socio</em>-technical things.”<span class="citation" data-cites="ko_what_2016"><a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a></span> Still, essays like Ko’s are quite remarkably few and far between, in the domain of the technical sciences as much as in the social sciences and the humanities — and often, as in this particular case, perhaps unavoidably perfunctory. Regardless of how we choose to explain it, Ko’s conclusion in 2016 that “[o]ther agendas, particular those that probe the human, social, societal, and ethical dimensions of PL, are hardly explored at all”<span class="citation" data-cites="ko_what_2016"><a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a></span> is certainly warranted.<a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a></p></section><section id="java-and-javascript" class="level2"><h2>Java and JavaScript</h2><p>In December 1995, when Sun Microsystems and Netscape Communications issued a joint press release announcing “JavaScript, the Open, Cross-Platform Object Scripting Language for Enterprise Networks and the Internet,”<span class="citation" data-cites="noauthor_netscape_1995"><a href="#fn14" class="footnote-ref" id="fnref14"><sup>14</sup></a></span> Sun’s Java programming language was already well on its way to achieving the virtually uncontested market dominance, comparative prestige, and privilege as an instructional language that it would enjoy for a decade and more. Though Java 1.0, the first public release, had appeared only the same year, Sun’s promise of true platform-neutrality and portability for the Java Runtime Environment was immediately attractive to enterprise software developers tiring of the demands placed on them by the C and C++ languages then widely in use. Java promised to moderate some of the complexity entailed by the access both C and C++ provided to low-level memory management, as well as the specific complexities introduced by C++ imagined as “C with classes,”<a href="#fn15" class="footnote-ref" id="fnref15"><sup>15</sup></a> without reducing the power and expressivity those languages offered to enterprise systems programmers specifically. Though it was initially designed for the lightweight hardware application of embedding in programmable consumer appliances, and only later adapted for serving and embedding in HTML pages, Java was very much a professional’s language, restrictive in its requirements for data types (being both statically and strongly typed) and in its promotion of a single programming style, the object-oriented programming (OOP) paradigm it would help popularize, as well as in the verbosity that both these forms of restriction produced. Presented as a professional alternative to both C and C++ rather than a radical departure from either, Java’s relative ease of use included no special claims of approachability for inexperienced coders or non-professionals.</p><p>Java<em>Script</em> was different. Sun and Netscape’s press release used the word “complementary” three times to describe JavaScript’s relation to Java: “JavaScript as a complement to Java” (in the document’s subtitle); “The JavaScript language complements Java”; “[JavaScript is] complementary to and integrated with Java.” Java, the press release emphasized, “is used by programmers to create new objects and applets,” while JavaScript “is designed for use by HTML page authors and enterprise application developers to dynamically script the behavior of objects running on either the client or the server.” If the mention of “enterprise application developers” and server-side applications suggested a place for JavaScript in the established industry of Java development, the sentence that followed better illuminates how HTML page authors were imagined, and how they imaged JavaScript’s complementing of Java in a different sense. “JavaScript is analogous to Visual Basic,” it read, “in that it can be used by people with little or no programming experience to quickly construct complex applications.”<span class="citation" data-cites="noauthor_netscape_1995"><a href="#fn16" class="footnote-ref" id="fnref16"><sup>16</sup></a></span></p><p>From its introduction, JavaScript’s reception by software developers, and its importance in “web development” as we now understand it (as an area of either software development or graphic design, depending on whom one asks), was structured by a continuous negotiation of expertise. Especially today, it is rare to encounter an introductory tutorial or textbook for beginners that fails to pause to disambiguate JavaScript from Java before undertaking to cover even the basics.<a href="#fn17" class="footnote-ref" id="fnref17"><sup>17</sup></a> Most often, and especially today, the motive for such disambiguation is less to clarify the historical relationship of these two languages than to clear a space for JavaScript by separating it from association with Java — specifically, with Java’s verbosity and its object-oriented programming paradigm, and perhaps from Java’s association with enterprise application programming, the drudge work of software engineering — and its diminished presence in the more flexible and experimental startup culture of the 2000s and 2010s, as well. While such gestures are understandable at a moment when Java’s reputation is more or less clearly in decline,<a href="#fn18" class="footnote-ref" id="fnref18"><sup>18</sup></a> they can obscure the historical entwinement of these two languages, with consequences that are regrettable from any but the most purely practical or instrumental perspective.</p><p>I use the term “improvised expertise” to describe both conditions for and effects of the unanticipated development of JavaScript from a mere complement to Java, designed for casual and inexpert programmers, into a language whose range and complexity of use has now propelled it ahead of Java in some ways, even (by some measures, in some domains) where Java once dominated. My argument is that such “improvised expertise” separates JavaScript at least partly from other, otherwise similar experiments in making programming accessible to non-experts, from the original BASIC language, developed as an instructional language at Dartmouth College in the 1960s, onward.</p><p>The concept of improvised expertise also encapsulates the conditions for and effects of three specific developmental dynamics in JavaScript’s recent history. First of these is a rapid acceleration in development of the language itself, now occurring at such a pace that ECMAScript, the specification on which JavaScript is based, shifted in 2015 from using traditional ordinal version numbers for editions to a year-based designation (so that the official name of ECMAScript version 6 is now ECMAScript 2015, with new editions to be released yearly going forward). Second is the recent abrupt emergence and extremely rapid growth of JavaScript in server-side networking, data processing, and other so-called back-end development tasks, a domain traditionally handled separately from the user-facing, design-oriented front-end site development that Sun and Netscape’s 1995 press release suggested would be JavaScript’s main use case. Third is the equally recent and abrupt, yet decisive emergence of JavaScript as the dominant language of a new generation of dynamic web application frameworks (principally Ember.js, AngularJS, and Facebook’s React, but also Meteor, Express, and others) and the developer tooling suites that support them, in a partial displacement of the Ruby language-based Rails framework popularized during the late 2000s.</p><p>This rapid, largely unanticipated growth in JavaScript’s range of application and its general importance in the software industry has even seen it enter elementary computer science instruction as language of preference, in some cases displacing Python (which itself has selectively displaced Java) in the classroom. Here, the phrase “improvised expertise” marks a paradox: while core JavaScript remains a small, approachable language when abstracted from its main domains of application, web site and application development, using JavaScript professionally in those domains today is virtually impossible without very substantial, ongoing study of the language’s advanced features and support for multiple programming paradigms, as well as of the new JavaScript-based development frameworks and tooling suites, the frenetic development pace of which virtually ensures that they will be replaced by other, newer frameworks and tools before they emerge from beta status and a commensurate level of documentation. This ensures that the learning curve for new professional JavaScript developers — not to mention the non-programmers JavaScript was originally designed to serve — will be very, very steep indeed, and it suggests that sooner or later, JavaScript’s improvised expertise will have some part to play in the disappointments of the latest push for “computer science for all” and other economic management schemes that conflate coding skills with basic literacy (that is, reading and writing in human languages) and with basic so-called computer literacy, as well (that is, using both general and domain-specific pre-packaged software applications effectively). Where JavaScript’s history as a programming language is in many ways a routine, if interesting case of simplification producing complexity, the logic of “coding for all” and its variants are arguably repetitions of magical thinking about the management of complexity in software production itself, with these two dynamics converging in the historical present.<a href="#fn19" class="footnote-ref" id="fnref19"><sup>19</sup></a> In that sense, what we call “JavaScript” is not just a programming language, and not just a collection of environments and tooling supporting a programming language, including specifications and other documentation, implementations, and primary and secondary program artifacts (from development tools and frameworks to specific interpreters or “engines,” compilers and transpilers, and other software components embedded in a browser or server applications). JavaScript can, at least at the moment and for the near term, be understood also as an assembly of broader technical and technical-historical dynamics, labor and management practices and arrangements, and discourses about education, job training, and production that privilege technical expertise, but also seek to generalize it in and for a demarcatable historical interval.</p></section><section id="system-and-scripting-languages" class="level2"><h2>System and scripting languages</h2><p>The first edition of ECMA-262 (ISO/IEC 16262), Ecma International’s specification for ECMAScript, a standard for JavaScript, was published in June, 1997. Edited by Guy L. Steele, Jr., it described ECMAScript as a scripting language, defining the latter as “a programming language that is used to manipulate, customize, and automate the facilities of an existing system,”<span class="citation" data-cites="noauthor_ecmascript:_1997"><a href="#fn20" class="footnote-ref" id="fnref20"><sup>20</sup></a></span> rather than being used to create a new system. It acknowledged that the “existing system” of ECMAScript’s original design was a World Wide Web page browser and a Web-based client-server architecture more generally, but also insisted that the ECMAScript specification had been written with a variety of possible host environments in mind.<span class="citation" data-cites="noauthor_ecmascript:_1997"><a href="#fn21" class="footnote-ref" id="fnref21"><sup>21</sup></a></span> The first edition of ECMA-262 was equally pointed, and in some ways more specific, in emphasizing that “[a] scripting language is intended for use by both professional and non-professional programmers, and therefore there may be a number of informalities and built into the language.”<span class="citation" data-cites="noauthor_ecmascript:_1997"><a href="#fn22" class="footnote-ref" id="fnref22"><sup>22</sup></a></span> The history of what we now call higher-level programming languages is of course a history of efforts to make programming less arduous for <em>professional</em> programmers, as operation codes provided mnemonics for instructions that could otherwise only be expressed in binary, octal, or other numeric form, followed by what we now call programming languages providing another, platform-independent layer atop the hardware-specific operation codes, a layer still more remote from numeric encoding and apparently closer to natural language (then and still today, the English language specifically).</p><p>Efforts to make programming accessible to non-professionals did not, as one might expect, lag the effort to make programming more convenient for professionals; rather, they were coterminous and developed in parallel, not without significant overlap. At Dartmouth College, John Kemeny had devised DARSIMCO (DARtmouth SIMplified COde), “Dartmouth’s first crack at a simple computer language,”<span class="citation" data-cites="kurtz_basic_1981"><a href="#fn23" class="footnote-ref" id="fnref23"><sup>23</sup></a></span> a year before the appearance in 1957 of FORTRAN, the first widely adopted and lasting example of a higher-level or “third generation” language.<a href="#fn24" class="footnote-ref" id="fnref24"><sup>24</sup></a> “Dartmouth students,” Thomas E. Kurtz recalled in 1978, “are interested mainly in subjects outside the sciences,” and most of the future “decision makers of business and government” among them were not science students.<span class="citation" data-cites="kurtz_basic_1981"><a href="#fn25" class="footnote-ref" id="fnref25"><sup>25</sup></a></span> The rationale for Dartmouth BASIC, or “Beginner’s All-Purpose Symbolic Instruction Code,” was to provide such students with experience in writing programs (rather than merely learning about computer use) without having to understand operation codes “or even FORTRAN or ALGOL” (the latter another higher-level language developed in the 1950s) which Kurtz and his colleagues considered “clearly out of the question. The majority would balk at the seemingly pointless detail.”<span class="citation" data-cites="kurtz_basic_1981"><a href="#fn26" class="footnote-ref" id="fnref26"><sup>26</sup></a></span> But the growth of Dartmouth BASIC into an entire family or class of languages represented its dissemination not only as an instructional language, but in some lines of development (such as that which produced Microsoft’s Visual Basic) as “a production programming language for professionals” as well.<span class="citation" data-cites="kurtz_basic_1981"><a href="#fn27" class="footnote-ref" id="fnref27"><sup>27</sup></a></span></p><p>Today, terminological usage more or less clearly distinguishes “scripting” languages from “system programming” languages. System programming languages like C and C++ were designed to abstract away much of the detail of assembly-language programming (that is, programming in operation codes) while still leaving the programmer facilities for manually allocating and deallocating memory and thus staying “close to the metal,” as programmers like to say, while enjoying the benefits of higher-level abstraction where that was preferred (for example, in syntax for iteration, branching and other control structures, function calls, and creating and managing collections of items of data). Managing memory efficiently involves distinguishing clearly among different data types (primarily, between mathematical and textual data types) as one makes use of them, so that no more memory than is needed is allocated for storing an item of data, and compilers for system programming languages typically enforce such discipline in the programmer — for example, by refusing to compile a working executable otherwise. Scripting languages, by contrast, abstract away and automate both data typing and memory allocation and deallocation, for the convenience of the programmer. This is partly because they they can take for granted the presence of an underlying system programming language and its libraries, for whose components they serve as a kind of adhesive or connective tissue, and in which they themselves are implemented (that is, the interpreter that provides a scripting language with its execution environment is itself a system-level language program).</p><p>Since the 1990s, however, various factors including the accelerating sophistication of hardware and innovations in programming language design have eroded some difference in the performance of scripting languages relative to system programming languages, at least in specific environments and for specific applications, and significant gains have arguably been made in some measures of programmer productivity. The economy of expression made possible once memory allocation and data typing is abstracted away can be fairly dramatic. If code in a system programming language like C is three to six times shorter, in countable individual instructions, than its equivalent in assembly language code,<span class="citation" data-cites="ousterhout_scripting:_1998"><a href="#fn28" class="footnote-ref" id="fnref28"><sup>28</sup></a></span> the same instructions in a scripting language like Python might be half as long as their equivalent in C, C++, or Java syntax, and depending on the task possibly much shorter than that.</p></section><section id="other-contexts" class="level2"><h2>Other contexts</h2><p>Although it took nearly two decades, it was JavaScript, rather than Java itself that made good on the promise of programmable Web pages and the browser application as a distributed multi-platform environment. As HTML-based Web publication promised to disrupt local monopolies of print publishers, JavaScript promised inexpert programmers access to a scriptable environment, while Java was to do the heavier lifting. In one of many interesting early formulations, the Web was imagined as a “shell” for interactive application development, by analogy with the AI-oriented “expert system” shells developed for use with Lisp and Prolog and marketed for rapid application prototyping in Java and other languages.<a href="#fn29" class="footnote-ref" id="fnref29"><sup>29</sup></a> But the popularity of the Web was also used to justify the teaching of JavaScript to novices and as a “precursor to Java.”<a href="#fn30" class="footnote-ref" id="fnref30"><sup>30</sup></a></p><p>The fading of Java’s promise as a browser language did not immediately elevate JavaScript. One writer of the late 1990s correctly anticipated the development of browser-independent implementations of JavaScript (fully realized in 2009 with Node.js, discussed below), but incorrectly expected JavaScript to be displaced by Perl as a browser scripting language.<a href="#fn31" class="footnote-ref" id="fnref31"><sup>31</sup></a> Today, after twenty years of emphasis on JavaScript’s role in client-side web development (that is, on the software browser’s presentation of data to the user), it is seldom remembered that Netscape Communications had explored server-side applications for JavaScript from the start. This is clear from the language of the 1995 joint press release with Sun, which specified that “JavaScript is an easy-to-use object scripting language designed for creating live online applications that link together objects and resources <em>on both clients and servers</em>,” and that it was “designed for use by HTML page authors and enterprise application developers to dynamically script the behavior of objects running on <em>either the client or the server</em>.”<span class="citation" data-cites="noauthor_netscape_1995"><a href="#fn32" class="footnote-ref" id="fnref32"><sup>32</sup></a></span><a href="#fn33" class="footnote-ref" id="fnref33"><sup>33</sup></a></p><p>Still, it is not difficult to identify in retrospect some conditions that arguably later served JavaScript’s explosive growth, including developments virtually coterminous with its first appearance. On April 30, 1995, the U.S. National Science Foundation’s NSFNET, a publicly funded network of supercomputer centers and telecommunications backbones serving academic research, was decommissioned, and the Internet as we know it today, unthinkable without private telecommunications carriers and Web-facilitated “e-commerce” and “B2B” or business-to-business transaction activity (to use two terms common in the mid- to late 1990s), began to take shape. America Online and Prodigy, up to that point private “online service” providers, also began offering access to the open Web. When the “Guide to the World Wide Web” created by Stanford graduate students Jerry Yang and David Filo was rebaptized “Yahoo!” and acquired the yahoo.com Web domain, large-scale Web indexing as a service was born.</p><p>Financial speculation linked to all these developments drove the Dow Jones Industrial Average past the 4,000-point threshold in February 1995 and the 5,000-point threshold in November, making two historic transitions in a single year. In this context, we are justified in remarking the larger context of the moment when JavaScript emerged as an instance of what I am calling “improvised expertise.” Facilitated by new consumer-friendly electronic financial networks and services, so-called day trading by individual small investors would grow by the late 1990s into a widely publicized pastime. Day traders responded rapidly to intraday price movements and sought out (as well exacerbated) price volatility, buying and holding stocks for as little as a few minutes at a time and making a point of closing their positions at the end of each day. Commercial service centers opened to provide such traders with the network and PC hardware, software, and data and financial services then unavailable to home PC users. As a mode of improvised expertise permitting individual, often inexperienced and inexpert speculators to bypass both the authority and the fees of stockbroker and other expert (or at least certified) financial service providers, day trading was associated with the volatility of so-called Internet stocks and the improvised company creation and management practices of the dot-com bubble, and it was famous for the financial disasters such securities inflicted on day traders themselves, long before they triggered a U.S. economic recession.<a href="#fn34" class="footnote-ref" id="fnref34"><sup>34</sup></a></p><p>The opening of securities markets to a new class of investor whose expertise was improvised, at best, was not the only significant economic event of 1995 and the years following it. It was in February 1995 that the 233-year-old Barings Bank, one of the world’s oldest surviving financial institutions, collapsed due to losses incurred by a single Singapore-based derivatives trader who relied on the global distribution of Barings’s operations help him evade scrutiny of his activities. Billionaire business publishing executive Steve Forbes launched his campaign for the 1996 Republican presidential nomination, refusing matching funds from the U.S. Federal Election Commission to avoid any obstruction in expending his personal wealth, a decision that would change U.S. national electoral campaign financing for good by removing the relative financial restraint imposed by FEC funds matching. Also in 1995, a new, fully formalized international institution, the World Trade Organization (WTO), replaced the treaty structure known as the General Agreement on Tariffs and Trade (GATT) that dated to the end of the Second World War — an event that might be understood as economically stabilizing, were it not for the prompt eruption of disputes between developed and developing-economy members (the as yet unresolved “Singapore issues”) and the attention of anti-globalization activists, which would culminate in violent street protests at the 1999 Seattle conference.</p><p>1995 was not an uneventful year politically, either. United States national political volatility increased as Speaker of the U.S. House of Representatives Newt Gingrich, capitalizing on Republican success in the 1994 midterm elections, finished crafting the insurgent conservative legislation known as the Contract with America and forced the first of a series of U.S. federal government closures in a dispute with President Bill Clinton. The nearly two-decade long bombing campaign of Theodore John “Ted” Kaczynski, a former University of California, Berkeley mathematician who had simultaneously renounced modern technology and taught himself to construct primitive explosives (and who had targeted academic scientists and computer stores in particular) culminated with a series of explanatory letters and the publication of the so-called “Unabomber Manifesto” by <em>The New York Times</em> and <em>The Washington Post.</em> And Timothy McVeigh and Terry Nichols destroyed the Alfred P. Murrah Federal Building in Oklahoma City with a truck bomb in the United States’ most significant act of domestic terrorism then and since.</p><p>While such details merely share a broad historical context with my topic of focus in this essay, the history of the JavaScript programming language, each of these details, from the emergence of newly privatized and newly publicly accessible Internet services, new economic governance institutions, and a new class of inexpert financial speculators, to what are still remembered today as very significant acts of domestic terrorism, involved conflicts and negotiations of technical expertise, in a broad sense, and some of them were marked by such conflicts and negotiations in the narrower sense relating specifically to computers, as well. In that sense, that broader context cannot be separated entirely from my topic here.</p></section><section id="javascript-as-multi-paradigm-programming-language" class="level2"><h2>JavaScript as multi-paradigm programming language</h2><p>The Java-like language that Brendan Eich was commissioned to design for the Netscape Navigator web browser in 1995 (a task that he reportedly completed in ten days) was initially named Mocha and then LiveScript. It acquired the name JavaScript with the joint press release issued by Sun and Netscape in December of that year, which I have already mentioned. In the two decades since, Java applets have almost completely vanished from the web, and it is JavaScript that provides the main interactive element in browser pages. Sun and Netscape’s joint press release reminds us just how far our current situation today is from the expectations they articulated in 1995. Though some of the rhetorical choices made in this text are perhaps more directly reflective of competition and licensing conflicts than anything else, it is worth dwelling on just how closely the respective domains of Java and JavaScript were positioned at the time:</p><ul><li>“The JavaScript language complements Java, Sun’s industry-leading object-oriented, cross-platform programming language.”</li><li>“JavaScript is an easy-to-use object scripting language designed for creating live online applications that link together objects and resources on both clients and servers. While Java is used by programmers to create new objects and applets, JavaScript is designed for use by HTML page authors and enterprise application developers to dynamically script the behavior of objects running on either the client or the server.”</li><li>“‘Programmers have been overwhelmingly enthusiastic about Java because it was designed from the ground up for the Internet. JavaScript is a natural fit, since it’s also designed for the Internet and Unicode-based worldwide use,’ said Bill Joy, co-founder and vice president of research at Sun. ‘JavaScript will be the most effective method to connect HTML-based content to Java applets’.”</li></ul><p>Java would be used to create code objects including applets (that is, small applications), and JavaScript programs would connect such objects and script (that is, configure and control) their behavior, providing them with a HTML-based user interface. If this particular separation of roles (Java as application programming language vs. JavaScript as scripting language) is clear, the attention the press release also devotes to “server-side JavaScript” may cloud it somewhat:</p><ul><li>“With JavaScript, an HTML page might contain an intelligent form that performs loan payment or currency exchange calculations right on the client in response to user input. A multimedia weather forecast applet written in Java can be scripted by JavaScript to display appropriate images and sounds based on the current weather readings in a region. A server-side JavaScript script might pull data out of a relational database and format it in HTML on the fly. A page might contain JavaScript scripts that run on both the client and the server. On the server, the scripts might dynamically compose and format HTML content based on user preferences stored in a relational database, and on the client, the scripts would glue together an assortment of Java applets and HTML form elements into a live interactive user interface for specifying a net-wide search for information.”</li><li>“Java programs and JavaScript scripts are designed to run on both clients and servers, with JavaScript scripts used to modify the properties and behavior of Java objects, so the range of live online applications that dynamically present information to and interact with users over enterprise networks or the Internet is virtually unlimited. Netscape will support Java and JavaScript in client and server products as well as programming tools and applications to make this vision a reality.”</li></ul><p>While there is no reason that two server-side programs (or for that matter, entire code bases) cannot maintain such distinctly complementary roles as are imagined here, the question of whether JavaScript might someday be able to perform alone in both such roles seems already latent in these formulations. Indeed, there exist unambiguous records of the tension around this issue, which it does not require much imagination to find in some of the joint press release’s strained locutions, which read like a parent ordering two sibling children to get along. As Eich has put it: “If I had done classes in JavaScript back in May 1995, I would have been told that it was too much like Java or that JavaScript was competing with Java […] I was under marketing orders to make it look like Java but not make it too big for its britches […] [JavaScript] needed to be a silly little brother language.”<span class="citation" data-cites="severance_computing_2012"><a href="#fn35" class="footnote-ref" id="fnref35"><sup>35</sup></a></span> Given that Java was already established, some at Netscape did not initially see any benefit in establishing and maintaining a separate language.<span class="citation" data-cites="severance_computing_2012"><a href="#fn36" class="footnote-ref" id="fnref36"><sup>36</sup></a></span></p><p>Under such conditions, it is unsurprising that JavaScript was designed and implemented in haste, and with the hope that its shortcomings could be addressed in continued development. Eich brought a great deal of both organic and improvised expertise to bear on JavaScript’s design. On the one hand, JavaScript’s syntax is derived from the systems programming language C, by way of Java’s own C-like syntax. On the other hand, Eich modeled JavaScript features like first-class functions and function closure on their equivalents in Scheme, a dialect of Lisp and so a member of a very different programming language family. Eich also adapted the prototype-based inheritance model of Self, a dialect of Smalltalk (a language and integrated programming environment designed in the 1970s for instructional and expressive computing), to provide JavaScript with object-oriented programming features. In combining these three quite different models — procedural or imperative in the case of C and Java, functional in the case of Scheme, and object-oriented in the case of Self — Eich made JavaScript a multi-paradigm language from the very start.</p><p>Although JavaScript was not the first such multi-paradigm language, such a synthesis is non-trivial in the design labor involved and in the prospects that JavaScript still presents for study even today. In synthesizing the three major programming paradigms, JavaScript certainly incorporated more complexity, even at the start, than most people would consider necessary in a language designed for novice and inexpert programmers. For novices, learning one programming model at a time (or only one model at all!) would certainly be considered more than enough. The tension between the design expertise that Eich brought to bear in creating JavaScript and its promotion as a language for inexpert users is especially interesting in Eich’s own statements, which wholeheartedly endorse such promotion:</p><blockquote><p>[W]hat people wanted back then (and still want) is the ability to go one step beyond HTML and add a little bit of code that makes a web page dynamic — that makes things move, respond to user input, or change color; that makes new windows pop up; or that raises a dialog box to ask a question, with an answer necessary to proceed — things that HTML cannot express. That’s really where you need a programming language, but something simpler than Java or C++. Content creation should not be recondite. It should not be this bizarre arcana that only experts and gold-plated computer science gurus can do.<span class="citation" data-cites="andreessen_innovators_1998"><a href="#fn37" class="footnote-ref" id="fnref37"><sup>37</sup></a></span></p></blockquote></section><section id="javascript-as-translational-programming-language" class="level2"><h2>JavaScript as translational programming language</h2><p>Despite borrowing most of its syntax from C and Java, JavaScript can certainly be written in a way that makes it resemble Scheme (see figure 1). To its explicit synthesis of multiple programming models or paradigms (procedural or imperative, functional, and object-oriented), and to the divergent idiomaticity facilitated by the incorporation of features from very different languages, whose syntactic expressions may deform JavaScript’s basically C-like syntax, we must add two other “multilingual” contexts for the development of JavaScript from 1995 to the present. The first is the development of of the ECMAScript standard, implementations of (and deviations from) the standard in major web browsers, and the ongoing, both forward and backward “translation” by which the development of the standard, its implementation in browsers, and its use in web programming are mediated. The second is the compilation of JavaScript to other, often non-related programming languages. I will describe each in turn.</p><p>[Figure 1]</p><div class="sourceCode" id="cb1"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">function</span> <span class="at">Y</span>(le) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="cf">return</span> (<span class="kw">function</span> (f) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">        <span class="cf">return</span> <span class="at">f</span>(f)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="op">}</span>(<span class="kw">function</span> (f) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">        <span class="cf">return</span> <span class="at">le</span>(<span class="kw">function</span> (x) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">            <span class="cf">return</span> <span class="at">f</span>(f)(x)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">        <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    <span class="op">}</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="op">}</span></a></code></pre></div><p>FIGURE CAPTION: The Applicative Order Y Combinator, from <span class="citation" data-cites="friedman_little_1996">Daniel P. Friedman and Matthias Felleisen,<a href="#fn38" class="footnote-ref" id="fnref38"><sup>38</sup></a></span> implemented by Douglas Crockford in JavaScript. See <span class="citation" data-cites="crockford_little_2003">Douglas Crockford.<a href="#fn39" class="footnote-ref" id="fnref39"><sup>39</sup></a></span></p><p>I have already mentioned the first edition of ECMA-262 (ISO/IEC 16262), Ecma International’s specification for ECMAScript, which described ECMAScript as a scripting language “intended for use by both professional and non-professional programmers.”<span class="citation" data-cites="noauthor_ecmascript:_1997"><a href="#fn40" class="footnote-ref" id="fnref40"><sup>40</sup></a></span> There exist seven published editions to date (ECMAScript 1, 2, 3, 5, 5.1, 6, and 7, excluding ECMAScript 4, which was abandoned), and the first edition’s emphasis on design for nonprofessional users was retained all the way through the fifth edition published in 2009. The third edition published in 1999 included minor changes to the initial paragraphs of the section titled “Overview” (section 4), changing “A scripting language is intended for use by both professional and non-professional programmers, and therefore there may be a number of informalities built into the language” to “A scripting language is intended for use by both professional and nonprofessional programmers. To accommodate non-professional programmers, some aspects of the language may be somewhat less strict.”<span class="citation" data-cites="noauthor_ecmascript_1999"><a href="#fn41" class="footnote-ref" id="fnref41"><sup>41</sup></a></span> The fifth edition published in 2009 deleted the latter sentence, leaving only “A scripting language is intended for use by both professional and nonprofessional programmers.”<span class="citation" data-cites="noauthor_ecmascript_2009"><a href="#fn42" class="footnote-ref" id="fnref42"><sup>42</sup></a></span></p><p>The sixth edition published in 2015 made much more significant changes, which put meaningful distance between JavaScript’s history and its present. To the paragraph defining a scripting language, a new sentence was prepended: “ECMAScript was originally designed to be used as a scripting language, but has become widely used as a general purpose programming language.”<span class="citation" data-cites="noauthor_ecmascript_2015"><a href="#fn43" class="footnote-ref" id="fnref43"><sup>43</sup></a></span> An entirely new paragraph was added elaborating this point:</p><blockquote><p>ECMAScript usage has moved beyond simple scripting and it is now used for the full spectrum of programming tasks in many different environments and scales. As the usage of ECMAScript has expanded, so has the features and facilities it provides. ECMAScript is now a fully featured general propose programming language.<span class="citation" data-cites="noauthor_ecmascript_2015"><a href="#fn44" class="footnote-ref" id="fnref44"><sup>44</sup></a></span></p></blockquote><p>Since the end of the ten-year interval separating the third and fifth editions, which saw the development and then abandonment of a fourth edition, feature addition has been rapid and extensive, with the fifth edition in 2009 and the sixth in 2015 both adding significant new features. After the long, partly fallow interval from 1999 to 2009, this rapid pace of development stimulated the development of a culture of experimental implementation in which features still only in proposed or only partially and non-bindingly approved form, in published drafts and other documents relation to the ECMAScript specification, were included in beta or developer versions of major web browsers, and eventually even in some user versions. Even before reaching a developer version of a web browser like Google Chrome, such features found their way into use through the mediation of source-to-source compilers (also called transcompilers or transpilers) that rewrote JavaScript code using experimental features in a form compliant with previously published editions of the ECMAScript specification (and thus guaranteed to work in user versions of browsers). At the same time, as other browser vendors (Microsoft with its Internet Explorer browser, and to a lesser extent Apple with its Safari browser) failed to implement all the features in already published past editions of the ECMAScript specification, transpilation was used to make JavaScript code uniformly executable across browser platforms.</p><p>Source-to-source compilation is as old as the history of higher-level programming languages themselves, with examples dating all the way back to the 1950s. The especially vigorous, even frenetic pace of such activity in web development and other JavaScript programming today merely hyper-animates the long history of <em>translation metaphors</em> through which the history of digital computing itself can be traced.<a href="#fn45" class="footnote-ref" id="fnref45"><sup>45</sup></a> Yet JavaScript programming may well be unique and unprecedented in the range and scale of such activity, if not in its mere fact. It is appropriate indeed that the most widely used source-to-source JavaScript compiler used to rewrite JavaScript code to conform to different ECMAScript specifications has the name Babel.<span class="citation" data-cites="noauthor_babel:_2016"><a href="#fn46" class="footnote-ref" id="fnref46"><sup>46</sup></a></span></p><p>We have not mentioned the many other programming languages that provide the option to transpile to JavaScript in addition to their original targets. An authoritative list includes not only many variants best described as JavaScript subsets, supersets, or extensions (many of them with names relating to coffee, such as the large CoffeeScript family), but compilers that will take in code in C/C++, Java, Perl, Python, Ruby, C#, Scala, Clojure, OCaml, Haskell, and other both major and minor, older and newer languages and rewrite it in JavaScript.<span class="citation" data-cites="ashkenas_list_2016"><a href="#fn47" class="footnote-ref" id="fnref47"><sup>47</sup></a></span> Here too, it is unlikely that anything else of this range and scale has ever been seen in the history of software programming. In a domain that is and has always been defined by constant translation, JavaScript programming culture can be distinguished as exceptionally <em>translational</em>.</p></section><section id="node.js" class="level2"><h2>Node.js</h2><p>A major, perhaps <em>the</em> major factor in the rapid expansion of JavaScript’s domain is the Node.js project, which dates to 2009. Node.js is a JavaScript runtime environment disembedded from the browser software application and written much as scripting languages like Python and Ruby are written: a developer may use command-line utilities, including a REPL (Read-Eval-Print Loop) and debugger, along with a software application text editor or Integrated Development Environment (IDE) to write and test programs locally on her or his own computer, but outside the browser application environment. The Node.js interpreter can run on a server, as well as on a desktop PC and in other software and networking contexts, and it can be embedded in a wide range of computing devices. While the earlier popularization of so-called Ajax (Asynchronous JavaScript and XML) programming techniques, closely associated with Google’s Maps products, certainly got the ball rolling in this respect, it may be Node.js more than any other single factor that has transformed JavaScript from a scripting language initially used disproportionately to create “annoyances” like browser pop-up windows<span class="citation" data-cites="severance_computing_2012"><a href="#fn48" class="footnote-ref" id="fnref48"><sup>48</sup></a></span> into something approaching a full-fledged systems programming language. Arguably, the Node.js project has revived, reactualized, and then realized the promise of the forgotten chapter of JavaScript’s history marked by Netscape’s early imagination and exploration of server-side JavaScript applications. For the first time since the appearance of the World Wide Web and the software browser application, Node.js unifies so-called front end and back end web development, so that so-called full stack developers, who write code for both user-facing and data processing components of an application, can use a single programming language for both tasks.</p><p>The applications of Node.js go beyond the server (though in that context, we should also mention the displacement of XML, as used in the earliest Ajax techniques, by the JavaScript-associated JSON [JavaScript Object Notation] data exchange format). Web application frameworks written in Node (Express.js and Meteor are two of the best known) have eroded the popularity of Rails, the Ruby-based application framework that dominated web development from the late 2000s onward. The Node-based Electron framework is increasingly used to develop platform-agnostic desktop GUI applications (that is, conventional applications that a user downloads and runs on her or his own machine, rather than using in a browser window). Node’s popularity also explains Apple’s inclusion in 2015 of JavaScript as one of the operating system languages of macOS (formerly OS X), usable for inter-application communication, as well as the inclusion of JavaScript “bridges” in the Apple iOS and Google Android operating systems for mobile platforms, enabling compilation to a JavaScript bound to the native system programming languages of those platforms (C, C++, Objective C/Swift, and Java).</p></section><section id="the-frameworks" class="level2"><h2>The frameworks</h2><p>For the reasons mentioned above, it is Node.js, more than anything else, that has driven the recent hyper-professionalization of JavaScript programming, removing the language quite decisively from that portion of its design origins that emphasized accessibility to inexpert and non-professional programmers. A development separate from the Node.js project, but of nearly equal impact on both JavaScript’s expansion and its hyper-professionalization, is the proliferation of other JavaScript-based web application frameworks <em>not</em> directly designed for or implemented in Node. The Ember.js, AngularJS, and React frameworks provide web developers with very sophisticated, unified abstractions of the three core browser technologies (HTML, CSS, and client-side JavaScript itself) that have made possible great leaps in both the sophistication of web applications and the creativity and productivity of those who write them. But they have also quite decisively propelled web development beyond the domain of accessibility imagined for the Web when it first appeared, which may have persisted in real terms for as long as ten years after 1995, in the sense that wage-earning web programming techniques could still be learned through casual and part-time training or retraining.</p><p>The professional construction and maintenance of web sites today requires both initial and ongoing training, and requires a level of skill maintenance and re-training, that puts it well out of reach for virtually anyone who is unable to devote her- or himself to its full-time pursuit — even academic researchers, excepting those who study and teach web technologies as a well-defined and well-developed technical research specialty. It is not the mere passage of time that makes the humanities-based wave of emancipatory hypertext theory of the 1990s, for example, seem so quaint,<a href="#fn49" class="footnote-ref" id="fnref49"><sup>49</sup></a> and makes its re-instantiation in the present “digital humanities” movement seem so disingenuous or so guileless, depending on whom one asks. It is not that JavaScript no longer stands for technical improvisation, but that in what I have been calling improvised expertise, expertise is now both unambiguously and unambivalently the agent of improvisation, instead of its object.</p></section><section id="javascript-fatigue-and-other-futures" class="level2"><h2>JavaScript fatigue — and other futures</h2><p>This shift has not been universally (or even broadly) welcomed. Indeed, the frenetic pace of change, if not the levels of skill required, is clearly a burden even to well-trained and experienced full-time professional developers. In early 2016, the phrase “JavaScript fatigue” began appearing in social media posts, blog writing, podcast discussion, and discussion at professional JavaScript developer conferences and briefly dominated such discussions as a collective preoccupation.<a href="#fn50" class="footnote-ref" id="fnref50"><sup>50</sup></a> The developer who began circulating the phrase had lamented the “confusing nest of build tools, boilerplate, linters, &amp; [other] time-sinks” that the individual and combined profusion of new language features, transpilers, frameworks, and other developer “tooling” (that is, custom applications for various programming tasks) represented: an entire preliminary phase of assessment and labor that was required before a JavaScript web application could even begin to be designed.<span class="citation" data-cites="clemmons_javascript_2015"><a href="#fn51" class="footnote-ref" id="fnref51"><sup>51</sup></a></span></p><p>It is this profusion, which many JavaScript developers find suffocating, that my intentionally lighthearted title “JavaScript Affogato” is intended to name, referring to the Italian dessert consisting of ice cream or other sweets “drowned” in espresso coffee.<a href="#fn52" class="footnote-ref" id="fnref52"><sup>52</sup></a> A soberer assessment would be bound to remind us that at some level, howsoever mediated, this hypertrophy of labor, and all the structural and personal strains that go with it, reflect or perhaps co-constitute the extensive economic violence of the interval beginning in 2008 and continuing to this day. Professional programmers have been among the few labor-market beneficiaries of an era of austerity and generalized economic pain and suffering, and such luck is nothing if not equally a curse. Certainly the significant priority placed on JavaScript, in particular, and its concomitant growth during this period, reflects the priorities declared by investment patterns focused on the user-facing “app” as a cultural token, associated with making and building things as “free” labor (free as in freedom) and adaptation to austerity, and as a new object of financial engineering.</p><p>In 2014 Brendan Eich’s resignation as CEO of the Mozilla Corporation, only nine days after taking the position, was described by a writer for <em>The New Yorker</em> as “the least surprising C.E.O. departure ever,” given that Silicon Valley was “a region of the business world where social liberalism is close to a universal ideology.”<span class="citation" data-cites="surowiecki_how_2014"><a href="#fn53" class="footnote-ref" id="fnref53"><sup>53</sup></a></span> (Eich’s having donated to an anti-marriage equality campaign supporting California’s ballot Proposition 8 in 2008 was a fact known beforehand, which became newly controversial upon Eich’s appointment.) It might be more accurate to say that in a broader context, the episode reflects the fundamental confusion of the specifically cyberlibertarian politics of Silicon Valley investment and management culture, which borrows ideas freely, but mostly unreflectively and unsynthetically from both statist left and anti-statist right-wing political platforms, in ways that seem to reflect the startup culture’s ambivalence about its own expertise. Though a great deal of work remains to be done to articulate the meaning such contexts lend to topics such as my own, in this essay, such social dynamics cannot be delinked from the technical history of the artifacts designed and produced in contexts determined by them — even, or perhaps especially, such an artifact as a programming language.</p></section><section id="references" class="level2 unnumbered"><h2>References</h2><div id="refs" class="references"><div id="ref-alba_ap_2016"><p>Alba, Davey. “The AP Finally Realizes It’s 2016, Will Let Us Stop Capitalizing ‘Internet’.” <em>Wired</em>, April 2016. <a href="http://www.wired.com/2016/04/ap-finally-realizes-2016-will-let-us-stop-capitalizing-internet/" class="uri">http://www.wired.com/2016/04/ap-finally-realizes-2016-will-let-us-stop-capitalizing-internet/</a>.</p></div><div id="ref-andreessen_innovators_1998"><p>Andreessen, Marc. “Innovators of the Net: Brendan Eich and Javascript,” June 1998. <a href="https://web.archive.org/web/20080208124612/http://wp.netscape.com/comprod/columns/techvision/innovators_be.html" class="uri">https://web.archive.org/web/20080208124612/http://wp.netscape.com/comprod/columns/techvision/innovators_be.html</a>.</p></div><div id="ref-ashkenas_list_2016"><p>Ashkenas, Jeremy. “List of Languages That Compile to JS.” GitHub, 2016. <a href="https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-JS" class="uri">https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-JS</a>.</p></div><div id="ref-noauthor_babel:_2016"><p>“Babel: A Compiler for Writing Next Generation Javascript,” 2016. <a href="https://babeljs.io/" class="uri">https://babeljs.io/</a>.</p></div><div id="ref-bemer_politico-social_1969"><p>Bemer, R. W. “A Politico-Social History of Algol (with a Chronology in the Form of a Log Book).” In <em>Annual Review of Automatic Programming</em>, 151–237. Annual Review of Automatic Programming 5. Pergamon, 1969.</p></div><div id="ref-bergin_history_2007"><p>Bergin, Thomas J. “A History of the History of Programming Languages.” <em>Commun. ACM</em> 50, no. 5 (May 2007): 69–74. doi:<a href="https://doi.org/10.1145/1230819.1230841">10.1145/1230819.1230841</a>.</p></div><div id="ref-bergin_history_1996"><p>Bergin, Thomas J., and Richard G. Gibson, eds. <em>History of Programming Languages II</em>. New York: ACM Press; Addison-Wesley, 1996.</p></div><div id="ref-braithwaite_javascript_2013"><p>Braithwaite, Reginald. <em>JavaScript Allongé</em>. Leanpub, 2013.</p></div><div id="ref-braithwaite_javascript_2015"><p>———. <em>JavaScript Spessore</em>. Leanpub, 2015.</p></div><div id="ref-britcher_limits_1999"><p>Britcher, Robert N. <em>The Limits of Software: People, Projects, and Perspectives</em>. Reading, MA: Addison-Wesley, 1999.</p></div><div id="ref-brooks_jr._mythical_1995"><p>Brooks, Frederick P., Jr. <em>The Mythical Man-Month: Essays on Software Engineering</em>. Anniversary edition. Reading, MA: Addison-Wesley, 1995.</p></div><div id="ref-campbell-kelly_airline_2004"><p>Campbell-Kelly, Martin. <em>From Airline Reservations to Sonic the Hedgehog: A History of the Software Industry</em>. History of Computing. Cambridge, Mass.: MIT Press, 2004.</p></div><div id="ref-cassel_evolve_2016"><p>Cassel, David. “Evolve or Die: Java, C++ Confront Newcomers on the TIOBE Index.” <em>The New Stack</em>, March 2016. <a href="https://thenewstack.io/evolve-die-popular-programming-languages-confront-newcomers-tiobe-index/" class="uri">https://thenewstack.io/evolve-die-popular-programming-languages-confront-newcomers-tiobe-index/</a>.</p></div><div id="ref-clark_netscape_1999"><p>Clark, Jim. <em>Netscape Time: The Making of the Billion-Dollar Start-up That Took on Microsoft</em>. New York: St. Martin’s Press, 1999.</p></div><div id="ref-clemmons_javascript_2015"><p>Clemmons, Eric. “JavaScript Fatigue.” <em>Medium</em>, December 2015. <a href="https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.c0ve3n241" class="uri">https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.c0ve3n241</a>.</p></div><div id="ref-severance_computing_2012"><p>“Computing Conversations with Brendan Eich,” January 2012. <a href="https://www.youtube.com/watch?v=IPxQ9kEaF8c" class="uri">https://www.youtube.com/watch?v=IPxQ9kEaF8c</a>.</p></div><div id="ref-crockford_javascript:_2008"><p>Crockford, Douglas. <em>Javascript: The Good Parts</em>. Beijing: O’Reilly, 2008.</p></div><div id="ref-crockford_little_2003"><p>———. “The Little JavaScripter.” <em>Douglas Crockford’s World Wide Web</em>, 2003. <a href="http://www.crockford.com/javascript/little.html" class="uri">http://www.crockford.com/javascript/little.html</a>.</p></div><div id="ref-cusumano_competing_1998"><p>Cusumano, Michael A., and David B. Yoffie. <em>Competing on Internet Time: Lessons from Netscape and Its Battle with Microsoft</em>. New York, NY: Free Press, 1998.</p></div><div id="ref-noauthor_ecmascript_1999"><p>“ECMAScript Language Specification: Standard ECMA-262, 3rd Edition.” ECMA, December 1999. <a href="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf">http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf</a>.</p></div><div id="ref-noauthor_ecmascript_2009"><p>“ECMAScript Language Specification: Standard ECMA-262, 5th Edition.” ECMA, December 2009. <a href="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262%205th%20edition%20December%202009.pdf">http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262%205th%20edition%20December%202009.pdf</a>.</p></div><div id="ref-noauthor_ecmascript_2015"><p>“ECMAScript Language Specification: Standard ECMA-262, 6th Edition.” ECMA, June 2015. <a href="http://www.ecma-international.org/ecma-262/6.0/" class="uri">http://www.ecma-international.org/ecma-262/6.0/</a>.</p></div><div id="ref-noauthor_ecmascript:_1997"><p>“ECMAScript: A General Purpose, Cross-Platform Programming Language. Standard Ecma-262, June 1997.” ECMA, June 1997. <a href="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%201st%20edition,%20June%201997.pdf">http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%201st%20edition,%20June%201997.pdf</a>.</p></div><div id="ref-flanagan_javascript:_2011"><p>Flanagan, David. <em>Javascript: The Definitive Guide</em>. 6th ed. Beijing ; Sebastopol, CA: O’Reilly, 2011.</p></div><div id="ref-french-owen_deep_2016"><p>French-Owen, Calvin. “The Deep Roots of Javascript Fatigue.” <em>Segment Blog</em>, March 2016. <a href="https://segment.com/blog/the-deep-roots-of-js-fatigue/" class="uri">https://segment.com/blog/the-deep-roots-of-js-fatigue/</a>.</p></div><div id="ref-friedman_little_1996"><p>Friedman, Daniel P., and Matthias Felleisen. <em>The Little Schemer</em>. 4th ed. Cambridge Mass: MIT Press, 1996.</p></div><div id="ref-hamilton_hooked_1999"><p>Hamilton, Walter. “Hooked on Speed: How Day Trading Works.” <em>The Los Angeles Times</em>, February 1999. <a href="http://articles.latimes.com/1999/feb/21/business/fi-10174" class="uri">http://articles.latimes.com/1999/feb/21/business/fi-10174</a>.</p></div><div id="ref-knuth_early_1976"><p>Knuth, Donald E., and Luis Trabb Pardo. “The Early Development of Programming Languages.” Stanford, CA, August 1976.</p></div><div id="ref-ko_what_2016"><p>Ko, Andrew J. “What Is a Programming Language, Really?” 32–33. ACM Press, 2016. doi:<a href="https://doi.org/10.1145/3001878.3001880">10.1145/3001878.3001880</a>.</p></div><div id="ref-kurtz_basic_1981"><p>Kurtz, Thomas E. “BASIC Session.” In <em>History of Programming Languages</em>, edited by Richard L. Wexelblat, 515–50. New York: Academic Press, 1981.</p></div><div id="ref-landow_hypertext:_1992"><p>Landow, George P. <em>Hypertext: The Convergence of Contemporary Critical Theory and Technology</em>. Parallax. Baltimore: Johns Hopkins University Press, 1992.</p></div><div id="ref-lee_developing_1997"><p>Lee, Alison, and Andreas Girgensohn. “Developing Collaborative Applications Using the World Wide Web &quot;Shell&quot;,” 144. ACM Press, 1997. doi:<a href="https://doi.org/10.1145/1120212.1120314">10.1145/1120212.1120314</a>.</p></div><div id="ref-mackenzie_cutting_2006"><p>Mackenzie, Adrian. <em>Cutting Code: Software and Sociality</em>. Digital Formations, v. 30. New York: Peter Lang, 2006.</p></div><div id="ref-marino_critical_2006"><p>Marino, Mark C. “Critical Code Studies.” <em>Electronic Book Review</em>, December 2006. <a href="http://www.electronicbookreview.com/thread/electropoetics/codology" class="uri">http://www.electronicbookreview.com/thread/electropoetics/codology</a>.</p></div><div id="ref-martin_application_1982"><p>Martin, James. <em>Application Development Without Programmers</em>. Englewood Cliffs, N.J: Prentice-Hall, 1982.</p></div><div id="ref-mcmillan_is_2013"><p>McMillan, Robert. “Is Java Losing Its Mojo?” <em>Wired</em>, January 2013. <a href="http://www.wired.com/2013/01/java-no-longer-a-favorite/" class="uri">http://www.wired.com/2013/01/java-no-longer-a-favorite/</a>.</p></div><div id="ref-mcpeak_beginning_2015"><p>McPeak, Jeremy, and Paul Wilton. <em>Beginning Javascript, 5th Edition</em>. 5th edition. Indianapolis, IN: John Wiley; Sons, 2015.</p></div><div id="ref-mercuri_using_1998"><p>Mercuri, Rebecca, Nira Herrmann, and Jeffrey Popyack. “Using HTML and JavaScript in Introductory Programming Courses.” <em>ACM SIGCSE Bulletin</em> 30, no. 1 (March 1998): 176–80. doi:<a href="https://doi.org/10.1145/274790.273754">10.1145/274790.273754</a>.</p></div><div id="ref-montfort_10_2013"><p>Montfort, Nick, Patsy Baudoin, John Bell, Ian Bogost, Jeremy Douglass, Mark C. Marino, Michael Mateas, Casey Reas, Mark Sample, and Noah Vawter. <em>10 PRINT CHR$(205.5+RND(1));:GOTO 10</em>. Computer software Studies. Cambridge, MA: MIT Press, 2013.</p></div><div id="ref-noauthor_netscape_1995"><p>“Netscape and Sun Announce Javascript, the Open, Cross-Platform Object Scripting Language for Enterprise Networks and the Internet,” December 1995. <a href="https://web.archive.org/web/20070916144913/http://wp.netscape.com/newsref/pr/newsrelease67.html" class="uri">https://web.archive.org/web/20070916144913/http://wp.netscape.com/newsref/pr/newsrelease67.html</a>.</p></div><div id="ref-nofre_when_2014"><p>Nofre, David, Mark Priestley, and Gerard Alberts. “When Technology Became Language: The Origins of the Linguistic Conception of Computer Programming, 1950–1960.” <em>Technology and Culture</em> 55, no. 1 (2014): 40–75. doi:<a href="https://doi.org/10.1353/tech.2014.0031">10.1353/tech.2014.0031</a>.</p></div><div id="ref-ousterhout_scripting:_1998"><p>Ousterhout, J.K. “Scripting: Higher Level Programming for the 21st Century.” <em>Computer</em> 31, no. 3 (1998): 23–30. doi:<a href="https://doi.org/10.1109/2.660187">10.1109/2.660187</a>.</p></div><div id="ref-paulson_for_2001"><p>Paulson, William. “For a Cosmopolitical Philology: Lessons from Science Studies.” <em>SubStance</em> 30, no. 3 (January 2001): 101–19. doi:<a href="https://doi.org/10.1353/sub.2001.0033">10.1353/sub.2001.0033</a>.</p></div><div id="ref-priestley_science_2010"><p>Priestley, Mark. <em>A Science of Operations: Machines, Logic and the Invention of Programming</em>. History of Computing. New York; London: Springer, 2010.</p></div><div id="ref-quittner_speeding_1998"><p>Quittner, Joshua, and Michelle Slatalla. <em>Speeding the Net: The Inside Story of Netscape and How It Challenged Microsoft</em>. New York: Atlantic Monthly Press, 1998.</p></div><div id="ref-reid_architects_1997"><p>Reid, Robert. <em>Architects of the Web: 1,000 Days That Built the Future of Business</em>. New York: John Wiley &amp; Sons, 1997.</p></div><div id="ref-rosenberg_dreaming_2008"><p>Rosenberg, Scott. <em>Dreaming in Code: Two Dozen Programmers, Three Years, 4,732 Bugs, and One Quest for Transcendent Software</em>. New York: Three Rivers Press, 2008.</p></div><div id="ref-sammet_programming_1969"><p>Sammet, Jean E. <em>Programming Languages: History and Fundamentals</em>. Englewood Cliffs, N.J.: Prentice-Hall, 1969.</p></div><div id="ref-simpson_up_2015"><p>Simpson, Kyle. <em>Up &amp; Going</em>. First Edition. You Don’t Know JS. Sebastopol, CA: O’Reilly Media, 2015.</p></div><div id="ref-snyder_java_2007"><p>Snyder, Bill. “Java Is Becoming the New Cobol.” <em>InfoWorld</em>, December 2007. <a href="http://www.infoworld.com/article/2650254/application-development/java-is-becoming-the-new-cobol.html" class="uri">http://www.infoworld.com/article/2650254/application-development/java-is-becoming-the-new-cobol.html</a>.</p></div><div id="ref-stroustrup_bjarne_2016"><p>Stroustrup, Bjarne. “Bjarne Stroustrup’s FAQ.” <em>Bjarne Stroustrup’s Homepage</em>, February 2016. <a href="http://www.stroustrup.com/bs_faq.html" class="uri">http://www.stroustrup.com/bs_faq.html</a>.</p></div><div id="ref-surowiecki_how_2014"><p>Surowiecki, James. “How Mozilla Lost Its C.E.O.” <em>The New Yorker</em>, April 2014. <a href="http://www.newyorker.com/business/currency/how-mozilla-lost-its-c-e-o" class="uri">http://www.newyorker.com/business/currency/how-mozilla-lost-its-c-e-o</a>.</p></div><div id="ref-ullman_close_2012"><p>Ullman, Ellen. <em>Close to the Machine: Technophilia and Its Discontents</em>. New York: Picador / Farrar, Straus,; Giroux, 2012.</p></div><div id="ref-ward_javascript_1998"><p>Ward, Robert, and Martin Smith. “Javascript as a First Programming Language for Multimedia Students.” <em>ACM SIGCSE Bulletin</em> 30, no. 3 (September 1998): 249–53. doi:<a href="https://doi.org/10.1145/290320.283557">10.1145/290320.283557</a>.</p></div><div id="ref-warren_oracles_2016"><p>Warren, Tom. “Oracle’s Finally Killing Its Terrible Java Browser Plugin.” <em>The Verge</em>, January 2016. <a href="http://www.theverge.com/2016/1/28/10858250/oracle-java-plugin-deprecation-jdk-9" class="uri">http://www.theverge.com/2016/1/28/10858250/oracle-java-plugin-deprecation-jdk-9</a>.</p></div><div id="ref-weinberg_psychology_1998"><p>Weinberg, Gerald M. <em>The Psychology of Computer Programming</em>. Silver anniversary edition. New York: Dorset House, 1998.</p></div><div id="ref-weiss_javascripting_1999"><p>Weiss, Aaron. “JavaScripting into the Next Millenniun.” <em>netWorker</em> 3, no. 4 (December 1999): 34–35. doi:<a href="https://doi.org/10.1145/323409.328683">10.1145/323409.328683</a>.</p></div><div id="ref-wexelblat_history_1981"><p>Wexelblat, Richard L., ed. <em>History of Programming Languages</em>. New York: Academic Press, 1981.</p></div></div></section><section class="footnotes"><hr><ol><li id="fn1"><p>Davey Alba, “The AP Finally Realizes It’s 2016, Will Let Us Stop Capitalizing ‘Internet’,” <em>Wired</em>, April 2016, <a href="http://www.wired.com/2016/04/ap-finally-realizes-2016-will-let-us-stop-capitalizing-internet/" class="uri">http://www.wired.com/2016/04/ap-finally-realizes-2016-will-let-us-stop-capitalizing-internet/</a>.<a href="#fnref1" class="footnote-back">↩</a></p></li><li id="fn2"><p>Tom Warren, “Oracle’s Finally Killing Its Terrible Java Browser Plugin,” <em>The Verge</em>, January 2016, <a href="http://www.theverge.com/2016/1/28/10858250/oracle-java-plugin-deprecation-jdk-9" class="uri">http://www.theverge.com/2016/1/28/10858250/oracle-java-plugin-deprecation-jdk-9</a>.<a href="#fnref2" class="footnote-back">↩</a></p></li><li id="fn3"><p>Some readers may also have thought of the acquisition of Yahoo Inc. by Verizon Communications, announced on July 25, 2016, several months after an initial draft of this essay was completed.<a href="#fnref3" class="footnote-back">↩</a></p></li><li id="fn4"><p>See <span class="citation" data-cites="brooks_jr._mythical_1995">Frederick P. Brooks Jr., <em>The Mythical Man-Month: Essays on Software Engineering</em>, Anniversary edition (Reading, MA: Addison-Wesley, 1995)</span>.<a href="#fnref4" class="footnote-back">↩</a></p></li><li id="fn5"><p>See <span class="citation" data-cites="mackenzie_cutting_2006">Adrian Mackenzie, <em>Cutting Code: Software and Sociality</em>, Digital Formations, v. 30 (New York: Peter Lang, 2006)</span>.<a href="#fnref5" class="footnote-back">↩</a></p></li><li id="fn6"><p>A partial exception is <span class="citation" data-cites="montfort_10_2013">Nick Montfort et al., <em>10 PRINT CHR$(205.5+RND(1));:GOTO 10</em>, Computer software Studies (Cambridge, MA: MIT Press, 2013)</span>, seven of the eleven main chapters of which focus on the BASIC programming language. Only one of these seven chapters could reasonably be called a study of the BASIC language, however, with the remaining six devoted to explaining very simple command sequences and very brief programs to readers who are assumed to have no knowledge either of BASIC or any other programming language. The book’s eighth main chapter, titled simply “BASIC,” does discuss language design and syntax variation in some detail, but is otherwise given over to reviewing BASIC’s implementation and usage history, again for a reader assumed to lack elementary knowledge of the subject. As of this writing, <em>10 PRINT CHR$(205.5+RND(1));:GOTO 10</em> is the only book-length publication to have emerged from “critical code studies,” an undertaking that <span class="citation" data-cites="marino_critical_2006">Mark C. Marino, “Critical Code Studies,” <em>Electronic Book Review</em>, December 2006, <a href="http://www.electronicbookreview.com/thread/electropoetics/codology" class="uri">http://www.electronicbookreview.com/thread/electropoetics/codology</a></span> attempted to distinguish from “software studies” more than a decade ago.<a href="#fnref6" class="footnote-back">↩</a></p></li><li id="fn7"><p>Mark Priestley, <em>A Science of Operations: Machines, Logic and the Invention of Programming</em>, History of Computing (New York; London: Springer, 2010), 2.<a href="#fnref7" class="footnote-back">↩</a></p></li><li id="fn8"><p>See <span class="citation" data-cites="sammet_programming_1969">Jean E. Sammet, <em>Programming Languages: History and Fundamentals</em> (Englewood Cliffs, N.J.: Prentice-Hall, 1969)</span>, <span class="citation" data-cites="knuth_early_1976">Donald E. Knuth and Luis Trabb Pardo, “The Early Development of Programming Languages” (Stanford, CA, August 1976)</span>, <span class="citation" data-cites="wexelblat_history_1981">Richard L. Wexelblat, ed., <em>History of Programming Languages</em> (New York: Academic Press, 1981)</span>, <span class="citation" data-cites="bergin_history_1996">Thomas J. Bergin and Richard G. Gibson, eds., <em>History of Programming Languages II</em> (New York: ACM Press; Addison-Wesley, 1996)</span>, <span class="citation" data-cites="bergin_history_2007">Thomas J. Bergin, “A History of the History of Programming Languages,” <em>Commun. ACM</em> 50, no. 5 (May 2007): 69–74, doi:<a href="https://doi.org/10.1145/1230819.1230841">10.1145/1230819.1230841</a></span>.<a href="#fnref8" class="footnote-back">↩</a></p></li><li id="fn9"><p>See <span class="citation" data-cites="campbell-kelly_airline_2004">Martin Campbell-Kelly, <em>From Airline Reservations to Sonic the Hedgehog: A History of the Software Industry</em>, History of Computing (Cambridge, Mass.: MIT Press, 2004)</span>.<a href="#fnref9" class="footnote-back">↩</a></p></li><li id="fn10"><p>William Paulson, “For a Cosmopolitical Philology: Lessons from Science Studies,” <em>SubStance</em> 30, no. 3 (January 2001): 101–19, doi:<a href="https://doi.org/10.1353/sub.2001.0033">10.1353/sub.2001.0033</a>.<a href="#fnref10" class="footnote-back">↩</a></p></li><li id="fn11"><p>Andrew J. Ko, “What Is a Programming Language, Really?” (ACM Press, 2016), 32, doi:<a href="https://doi.org/10.1145/3001878.3001880">10.1145/3001878.3001880</a>.<a href="#fnref11" class="footnote-back">↩</a></p></li><li id="fn12"><p>Ko, “What Is a Programming Language, Really?” 33.<a href="#fnref12" class="footnote-back">↩</a></p></li><li id="fn13"><p>The “politico-social history of Algol” promised by <span class="citation" data-cites="bemer_politico-social_1969">R. W. Bemer, “A Politico-Social History of Algol (with a Chronology in the Form of a Log Book),” in <em>Annual Review of Automatic Programming</em>, Annual Review of Automatic Programming 5 (Pergamon, 1969), 151–237</span>, for example, turns out to be a bibliography with abridged extracts from various primary sources (letters, meeting minutes, committee resolutions, and so on), many relating to the famously fractious negotiations of the specification of Algol 60 in particular. It is to that history of conflict to which the term “politico-social” presumably refers; still, this document is entirely descriptive and offers no analysis whatsoever.<a href="#fnref13" class="footnote-back">↩</a></p></li><li id="fn14"><p>“Netscape and Sun Announce Javascript, the Open, Cross-Platform Object Scripting Language for Enterprise Networks and the Internet,” December 1995, <a href="https://web.archive.org/web/20070916144913/http://wp.netscape.com/newsref/pr/newsrelease67.html" class="uri">https://web.archive.org/web/20070916144913/http://wp.netscape.com/newsref/pr/newsrelease67.html</a>.<a href="#fnref14" class="footnote-back">↩</a></p></li><li id="fn15"><p>Designed by Bjarne Stroustrup while working at AT&amp;T in the late 1970s, C++ was originally called “C with Classes,” marking Stroustrup’s intention to “superset” the C language (that is, to remain completely compatible with it) while also improving it. See <span class="citation" data-cites="stroustrup_bjarne_2016">Bjarne Stroustrup, “Bjarne Stroustrup’s FAQ,” <em>Bjarne Stroustrup’s Homepage</em>, February 2016, <a href="http://www.stroustrup.com/bs_faq.html" class="uri">http://www.stroustrup.com/bs_faq.html</a></span>.<a href="#fnref15" class="footnote-back">↩</a></p></li><li id="fn16"><p>“Netscape and Sun Announce Javascript, the Open, Cross-Platform Object Scripting Language for Enterprise Networks and the Internet.”<a href="#fnref16" class="footnote-back">↩</a></p></li><li id="fn17"><p>See, for example, <span class="citation" data-cites="mcpeak_beginning_2015">Jeremy McPeak and Paul Wilton, <em>Beginning Javascript, 5th Edition</em>, 5th edition (Indianapolis, IN: John Wiley; Sons, 2015)</span>, 2: “Perhaps this is a good place to dispel a widespread myth: JavaScript is not the script version of the Java language. In fact, although they share the same name, that’s virtually all they do share. Particularly good news is that JavaScript is much, much easier to learn and use than Java.” Even some classic books on JavaScript written for developers already expert in other languages, or newer books who address the same kind of reader, frame the issue similarly. In <em>JavaScript: The Definitive Guide,</em> widely considered an authoritative comprehensive study of JavaScript, David Flanagan begins thus: “The name ‘JavaScript’ is actually somewhat misleading. Except for a superficial syntactic resemblance, JavaScript is completely different from the Java programming language” <span class="citation" data-cites="flanagan_javascript:_2011">David Flanagan, <em>Javascript: The Definitive Guide</em>, 6th ed (Beijing ; Sebastopol, CA: O’Reilly, 2011), 1</span>. In the introductory volume of a rigorous and well-received multi-volume study of contemporary JavaScript, Kyle Simpson writes, “[T]he name [JavaScript] is merely an accident of politics and marketing. The two languages are vastly different in many important ways. ‘JavaScript’ is as related to ‘Java’ as ‘Carnival’ is to ‘Car’” <span class="citation" data-cites="simpson_up_2015">Kyle Simpson, <em>Up &amp; Going</em>, First Edition, You Don’t Know JS (Sebastopol, CA: O’Reilly Media, 2015), vii</span>. Douglas Crockford reminds us of Java and JavaScript’s historical concurrency and doesn’t exaggerate their unrelatedness, but has little to say about the issue beyond one sentence: “When Java™ applets failed, JavaScript became the ‘Language of the Web’ by default” <span class="citation" data-cites="crockford_javascript:_2008">Douglas Crockford, <em>Javascript: The Good Parts</em> (Beijing: O’Reilly, 2008), 1</span>.<a href="#fnref17" class="footnote-back">↩</a></p></li><li id="fn18"><p>In response to such claims, Java programmers often point to Java’s leading position in the TIOBE Programming Community Index compiled by the software services provider TIOBE Software BV, or similar rankings aggregators like the PYPL Popularity of Programming Language Index — leaving unmentioned such rankings’ historical “trend” indexes for Java’s position, which are frequently negative. See <span class="citation" data-cites="mcmillan_is_2013">Robert McMillan, “Is Java Losing Its Mojo?” <em>Wired</em>, January 2013, <a href="http://www.wired.com/2013/01/java-no-longer-a-favorite/" class="uri">http://www.wired.com/2013/01/java-no-longer-a-favorite/</a></span> and <span class="citation" data-cites="cassel_evolve_2016">David Cassel, “Evolve or Die: Java, C++ Confront Newcomers on the TIOBE Index,” <em>The New Stack</em>, March 2016, <a href="https://thenewstack.io/evolve-die-popular-programming-languages-confront-newcomers-tiobe-index/" class="uri">https://thenewstack.io/evolve-die-popular-programming-languages-confront-newcomers-tiobe-index/</a></span>, both of whom argue that TIOBE data itself shows Java’s position “slipping” and “trending down” (McMillan also quotes Paul Jansen, managing director of TIOBE Software, as stating that “Java is falling down”). In any case, at any point in the history of a programming language past the point of its initial adoption, a language’s reputation — as expressive or otherwise pleasant to use, as adaptable to ongoing hardware evolution, as usable in solving newer computational problems — may diverge from its market share or other measures of usage quite radically, if only because once they are in place, large industrial software infrastructures are kept operating for as long as possible. It is the incongruence of Java’s reputation with its market share, today, that animates non-meaningless if possibly glib comparisons of Java to Cobol, such as that made by <span class="citation" data-cites="snyder_java_2007">Bill Snyder, “Java Is Becoming the New Cobol,” <em>InfoWorld</em>, December 2007, <a href="http://www.infoworld.com/article/2650254/application-development/java-is-becoming-the-new-cobol.html" class="uri">http://www.infoworld.com/article/2650254/application-development/java-is-becoming-the-new-cobol.html</a></span>. The inclusion in Java version 9 of a REPL (Read-Evaluate-Print-Loop) feature for exploratory programming is a concession to the encroachment on Java’s position of both scripting languages and newer functional programming languages, languages in both categories of which have offered REPL-type features — whose purpose and usage are fundamentally incompatible with Java-style object oriented programming — for many decades. Arguably, the rise of Scala, Clojure, and other languages designed to run on the Java Virtual Machine (JVM) and provide access to Java standard libraries, but otherwise breaking either partly or completely with Java’s imperative syntax and its enforcement of an object-oriented paradigm, marks the endurance of the JVM as a platform but the eclipse of Java as a (paradigmatic) language.<a href="#fnref18" class="footnote-back">↩</a></p></li><li id="fn19"><p>The difficulties of larger-scale software production are documented by a management-oriented literature stretching back to the 1970s. The canonical text, mentioned previously, is Frederick P. Brooks, Jr., <em>The Mythical Man-Month: Essays on Software Engineering</em> (1975). See <span class="citation" data-cites="brooks_jr._mythical_1995">Brooks, <em>The Mythical Man-Month</em></span>, along with <span class="citation" data-cites="britcher_limits_1999">Robert N. Britcher, <em>The Limits of Software: People, Projects, and Perspectives</em> (Reading, MA: Addison-Wesley, 1999)</span>, <span class="citation" data-cites="rosenberg_dreaming_2008">Scott Rosenberg, <em>Dreaming in Code: Two Dozen Programmers, Three Years, 4,732 Bugs, and One Quest for Transcendent Software</em> (New York: Three Rivers Press, 2008)</span>, <span class="citation" data-cites="weinberg_psychology_1998">Gerald M. Weinberg, <em>The Psychology of Computer Programming</em>, Silver anniversary edition (New York: Dorset House, 1998)</span>, and, for useful counterpoint, <span class="citation" data-cites="ullman_close_2012">Ellen Ullman, <em>Close to the Machine: Technophilia and Its Discontents</em> (New York: Picador / Farrar, Straus,; Giroux, 2012)</span>.<a href="#fnref19" class="footnote-back">↩</a></p></li><li id="fn20"><p>“ECMAScript: A General Purpose, Cross-Platform Programming Language. Standard Ecma-262, June 1997” (ECMA, June 1997), 1, <a href="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%201st%20edition,%20June%201997.pdf">http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%201st%20edition,%20June%201997.pdf</a>.<a href="#fnref20" class="footnote-back">↩</a></p></li><li id="fn21"><p>“ECMAScript,” 2.<a href="#fnref21" class="footnote-back">↩</a></p></li><li id="fn22"><p>“ECMAScript,” 1.<a href="#fnref22" class="footnote-back">↩</a></p></li><li id="fn23"><p>Thomas E. Kurtz, “BASIC Session,” in <em>History of Programming Languages</em>, ed. Richard L. Wexelblat (New York: Academic Press, 1981), 516.<a href="#fnref23" class="footnote-back">↩</a></p></li><li id="fn24"><p>The most widely used term in both professional software development and the discipline of computer science is “higher level language,” a spatial metaphor used to describe abstraction from the “lower” level of hardware operation codes. Academic researchers use the historical metaphor of the generation in a similar, if perhaps also more sensible way: a first generation of purely numerically represented instructions (“machine code”) is followed by a second generation of mnemonic abbreviations (“assembly language”), followed in turn by compiled, hardware-independent algebraic syntaxes and keywords and phrases in the English language (“programming language” as we use the term today). The classification includes a fourth and a fifth generation, which is beyond my purview here. See <span class="citation" data-cites="martin_application_1982">James Martin, <em>Application Development Without Programmers</em> (Englewood Cliffs, N.J: Prentice-Hall, 1982)</span>.<a href="#fnref24" class="footnote-back">↩</a></p></li><li id="fn25"><p>Kurtz, “BASIC Session,” 518.<a href="#fnref25" class="footnote-back">↩</a></p></li><li id="fn26"><p>Kurtz, “BASIC Session,” 518.<a href="#fnref26" class="footnote-back">↩</a></p></li><li id="fn27"><p>Kurtz, “BASIC Session,” 547.<a href="#fnref27" class="footnote-back">↩</a></p></li><li id="fn28"><p>J.K. Ousterhout, “Scripting: Higher Level Programming for the 21st Century,” <em>Computer</em> 31, no. 3 (1998): 24, doi:<a href="https://doi.org/10.1109/2.660187">10.1109/2.660187</a>.<a href="#fnref28" class="footnote-back">↩</a></p></li><li id="fn29"><p>See <span class="citation" data-cites="lee_developing_1997">Alison Lee and Andreas Girgensohn, “Developing Collaborative Applications Using the World Wide Web &quot;Shell&quot;” (ACM Press, 1997), 144, doi:<a href="https://doi.org/10.1145/1120212.1120314">10.1145/1120212.1120314</a></span>.<a href="#fnref29" class="footnote-back">↩</a></p></li><li id="fn30"><p>See <span class="citation" data-cites="ward_javascript_1998">Robert Ward and Martin Smith, “Javascript as a First Programming Language for Multimedia Students,” <em>ACM SIGCSE Bulletin</em> 30, no. 3 (September 1998): 249–53, doi:<a href="https://doi.org/10.1145/290320.283557">10.1145/290320.283557</a></span>, 249: “The World-Wide Web is increasingly influencing the teaching of Computing Science and associated subjects, and Web-related programming topics are now appearing in many syllabuses. Whilst in this respect there has been much development and discussion of Java as a first programming language with many text books now available, JavaScript has been comparatively ignored. […] We propose here that JavaScript is sufficiently rich in concepts to support the teaching of introductory programming, and that it is especially suitable for Multimedia students.” See also <span class="citation" data-cites="mercuri_using_1998">Rebecca Mercuri, Nira Herrmann, and Jeffrey Popyack, “Using HTML and JavaScript in Introductory Programming Courses,” <em>ACM SIGCSE Bulletin</em> 30, no. 1 (March 1998): 176–80, doi:<a href="https://doi.org/10.1145/274790.273754">10.1145/274790.273754</a></span>, 176: “Here we report on a course designed to exploit students’ burgeoning interest in the World Wide Web (WWW), where we used HTML and JavaScript to teach programming concepts. These languages allow students at different skill levels to work side by side, learning common abstract ideas while implementing them at different levels of complexity, motivated by the rewarding and exciting interactive environment of the WWW.”<a href="#fnref30" class="footnote-back">↩</a></p></li><li id="fn31"><p>See <span class="citation" data-cites="weiss_javascripting_1999">Aaron Weiss, “JavaScripting into the Next Millenniun,” <em>netWorker</em> 3, no. 4 (December 1999): 34–35, doi:<a href="https://doi.org/10.1145/323409.328683">10.1145/323409.328683</a></span>, 35: “As a programming language alone, JavaScript’s main appeal has been its simple learning curve, but to more experienced programmers it lacks serious muscle-power. There are sharks in these waters — established, mature programming languages such as Perl can now be embedded into some Web browsers […] For a seasoned developer, the prospect of combining client-side Perl — with its agile handling of advanced programming models — with access to the DOM would be lethal to JavaScript. We will likely see the migration of other scripting language into the Web client as well, including Python, TCL, SmallTalk, and perhaps more.”<a href="#fnref31" class="footnote-back">↩</a></p></li><li id="fn32"><p>“Netscape and Sun Announce Javascript, the Open, Cross-Platform Object Scripting Language for Enterprise Networks and the Internet,” emphasis added.<a href="#fnref32" class="footnote-back">↩</a></p></li><li id="fn33"><p>On the early history of Netscape, see <span class="citation" data-cites="reid_architects_1997">Robert Reid, <em>Architects of the Web: 1,000 Days That Built the Future of Business</em> (New York: John Wiley &amp; Sons, 1997)</span>, <span class="citation" data-cites="cusumano_competing_1998">Michael A. Cusumano and David B. Yoffie, <em>Competing on Internet Time: Lessons from Netscape and Its Battle with Microsoft</em> (New York, NY: Free Press, 1998)</span>, <span class="citation" data-cites="quittner_speeding_1998">Joshua Quittner and Michelle Slatalla, <em>Speeding the Net: The Inside Story of Netscape and How It Challenged Microsoft</em> (New York: Atlantic Monthly Press, 1998)</span>, and <span class="citation" data-cites="clark_netscape_1999">Jim Clark, <em>Netscape Time: The Making of the Billion-Dollar Start-up That Took on Microsoft</em> (New York: St. Martin’s Press, 1999)</span>.<a href="#fnref33" class="footnote-back">↩</a></p></li><li id="fn34"><p>See <span class="citation" data-cites="hamilton_hooked_1999">Walter Hamilton, “Hooked on Speed: How Day Trading Works,” <em>The Los Angeles Times</em>, February 1999, <a href="http://articles.latimes.com/1999/feb/21/business/fi-10174" class="uri">http://articles.latimes.com/1999/feb/21/business/fi-10174</a></span>.<a href="#fnref34" class="footnote-back">↩</a></p></li><li id="fn35"><p>Qtd. in “Computing Conversations with Brendan Eich,” January 2012, <a href="https://www.youtube.com/watch?v=IPxQ9kEaF8c" class="uri">https://www.youtube.com/watch?v=IPxQ9kEaF8c</a>.<a href="#fnref35" class="footnote-back">↩</a></p></li><li id="fn36"><p>“Computing Conversations with Brendan Eich.”<a href="#fnref36" class="footnote-back">↩</a></p></li><li id="fn37"><p>Marc Andreessen, “Innovators of the Net: Brendan Eich and Javascript,” June 1998, <a href="https://web.archive.org/web/20080208124612/http://wp.netscape.com/comprod/columns/techvision/innovators_be.html" class="uri">https://web.archive.org/web/20080208124612/http://wp.netscape.com/comprod/columns/techvision/innovators_be.html</a>.<a href="#fnref37" class="footnote-back">↩</a></p></li><li id="fn38"><p><em>The Little Schemer</em>, 4th ed (Cambridge Mass: MIT Press, 1996).<a href="#fnref38" class="footnote-back">↩</a></p></li><li id="fn39"><p>“The Little JavaScripter,” <em>Douglas Crockford’s World Wide Web</em>, 2003, <a href="http://www.crockford.com/javascript/little.html" class="uri">http://www.crockford.com/javascript/little.html</a>.<a href="#fnref39" class="footnote-back">↩</a></p></li><li id="fn40"><p>“ECMAScript,” 1.<a href="#fnref40" class="footnote-back">↩</a></p></li><li id="fn41"><p>“ECMAScript Language Specification: Standard ECMA-262, 3rd Edition” (ECMA, December 1999), 1, <a href="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf">http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf</a>.<a href="#fnref41" class="footnote-back">↩</a></p></li><li id="fn42"><p>“ECMAScript Language Specification: Standard ECMA-262, 5th Edition” (ECMA, December 2009), 2, <a href="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262%205th%20edition%20December%202009.pdf">http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262%205th%20edition%20December%202009.pdf</a>.<a href="#fnref42" class="footnote-back">↩</a></p></li><li id="fn43"><p>“ECMAScript Language Specification: Standard ECMA-262, 6th Edition” (ECMA, June 2015), <a href="http://www.ecma-international.org/ecma-262/6.0/" class="uri">http://www.ecma-international.org/ecma-262/6.0/</a>.<a href="#fnref43" class="footnote-back">↩</a></p></li><li id="fn44"><p>“ECMAScript Language Specification.”<a href="#fnref44" class="footnote-back">↩</a></p></li><li id="fn45"><p>See <span class="citation" data-cites="nofre_when_2014">David Nofre, Mark Priestley, and Gerard Alberts, “When Technology Became Language: The Origins of the Linguistic Conception of Computer Programming, 1950–1960,” <em>Technology and Culture</em> 55, no. 1 (2014): 40–75, doi:<a href="https://doi.org/10.1353/tech.2014.0031">10.1353/tech.2014.0031</a></span>.<a href="#fnref45" class="footnote-back">↩</a></p></li><li id="fn46"><p>“Babel: A Compiler for Writing Next Generation Javascript,” 2016, <a href="https://babeljs.io/" class="uri">https://babeljs.io/</a>.<a href="#fnref46" class="footnote-back">↩</a></p></li><li id="fn47"><p>Jeremy Ashkenas, “List of Languages That Compile to JS” (GitHub, 2016), <a href="https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-JS" class="uri">https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-JS</a>.<a href="#fnref47" class="footnote-back">↩</a></p></li><li id="fn48"><p>“Computing Conversations with Brendan Eich.”<a href="#fnref48" class="footnote-back">↩</a></p></li><li id="fn49"><p>See, for example, <span class="citation" data-cites="landow_hypertext:_1992">George P. Landow, <em>Hypertext: The Convergence of Contemporary Critical Theory and Technology</em>, Parallax (Baltimore: Johns Hopkins University Press, 1992)</span>.<a href="#fnref49" class="footnote-back">↩</a></p></li><li id="fn50"><p>See <span class="citation" data-cites="clemmons_javascript_2015">Eric Clemmons, “JavaScript Fatigue,” <em>Medium</em>, December 2015, <a href="https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.c0ve3n241" class="uri">https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.c0ve3n241</a></span> and <span class="citation" data-cites="french-owen_deep_2016">Calvin French-Owen, “The Deep Roots of Javascript Fatigue,” <em>Segment Blog</em>, March 2016, <a href="https://segment.com/blog/the-deep-roots-of-js-fatigue/" class="uri">https://segment.com/blog/the-deep-roots-of-js-fatigue/</a></span>.<a href="#fnref50" class="footnote-back">↩</a></p></li><li id="fn51"><p>Clemmons, “JavaScript Fatigue.”<a href="#fnref51" class="footnote-back">↩</a></p></li><li id="fn52"><p>“JavaScript Affogato” is a variation on (and homage to) the witty phrasing of Reginald Brathwaite in a series of advanced, theoretically sophisticated books on JavaScript. See <span class="citation" data-cites="braithwaite_javascript_2013">Reginald Braithwaite, <em>JavaScript Allongé</em> (Leanpub, 2013)</span> and <span class="citation" data-cites="braithwaite_javascript_2015">Reginald Braithwaite, <em>JavaScript Spessore</em> (Leanpub, 2015)</span>.<a href="#fnref52" class="footnote-back">↩</a></p></li><li id="fn53"><p>James Surowiecki, “How Mozilla Lost Its C.E.O.” <em>The New Yorker</em>, April 2014, <a href="http://www.newyorker.com/business/currency/how-mozilla-lost-its-c-e-o" class="uri">http://www.newyorker.com/business/currency/how-mozilla-lost-its-c-e-o</a>.<a href="#fnref53" class="footnote-back">↩</a></p></li></ol></section></div></div></section><div class="pure-g"><footer><a href="https://bitfragment.github.io/mindoc">mindoc</a> v1.1.0</footer></div><script>var mindoc=function(){function e(e){return e=e.toLowerCase(),e.charAt(0).toUpperCase()+e.substr(1)}function n(e){var n=new RegExp(/^\b[a-z]\S+\b-\b\S+\b/);return n.test(e)&&(e=e.replace(/-+/g," ")),e}function t(t){return t=n(t),e(t)}function r(e,n){return!!e.className.match(new RegExp("(\\s|^)"+n+"(\\s|)"))}function a(e,n){r(e,n)||(e.className+=" "+n)}function o(e,n){if(r(e,n)){var t=new RegExp("(\\s|^)"+n+"(\\s|)");e.className=e.className.replace(t," ")}}function u(){var e,n,t={table:"pure-table pure-table-bordered"};Object.keys(t).forEach(function(r){if(e=document.getElementsByTagName(r),n=e.length,n>1)for(var o=0;n>o;o++)a(e[o],t[r])})}function c(e,n){for(var t=0,r=e.length;r>t;t++)for(var a=e[t].getElementsByTagName("a"),u=0,c=a.length;c>u;u++)a[u].addEventListener("click",function(){o(n,"hidden")})}function i(e,n){for(var t=0,r=e.length;r>t;t++)e[t].addEventListener("click",function(){o(n,"hidden")})}function d(){var e=document.createElement("li");return a(e,"pure-menu-item"),e}function l(e){var n=document.createElement("a");return n.id="menu-"+e,n.href="#",n.innerHTML=t(e),a(n,"pure-menu-link"),n}function m(e){var n=document.createDocumentFragment(),t=document.createElement("nav"),r=document.createElement("div"),o=document.createElement("ul");n.appendChild(t),t.appendChild(r),r.appendChild(o),a(r,"pure-menu"),a(o,"pure-menu-list");var u="All sections",c=d();a(c,"pure-menu-selected"),o.appendChild(c),c.appendChild(l(u));for(var i,m,s=0,f=e.length;f>s;s++)i=e[s].getAttribute("id"),m=d(),o.appendChild(m),m.appendChild(l(i));var p=document.getElementById("page-content");document.querySelector("body").insertBefore(n,p)}function s(e){var n;e.hasAttribute("pure-menu-selected")||(n=document.querySelector(".pure-menu-selected"),o(n,"pure-menu-selected"),a(e,"pure-menu-selected"))}function f(e,n){var t,u=n.getAttribute("id"),c=u.replace(/menu-/,""),i=document.getElementById(u).parentNode;s(i);for(var d in e)t=e[d],r(t,"hidden")||a(t,"hidden"),t.getAttribute("id")===c&&r(t,"hidden")&&o(t,"hidden")}function p(e){var n;for(var t in e)n=e[t],r(n,"hidden")&&o(n,"hidden")}function v(e){for(var n=document.querySelectorAll(".pure-menu-link"),t=0,r=n.length;r>t;t++)0===t?n[t].addEventListener("click",function(){p(e)}):n[t].addEventListener("click",function(){f(e,this)})}return{main:function(){if(u(),document.getElementsByClassName("level2").length>0){var e,n=[];["abstract","level2","footnotes"].forEach(function(t){e=document.getElementsByClassName(t);for(var r=0,a=e.length;a>r;r++)n.push(e[r])});var t;for(var o in n)t=n[o],r(t,"level2")||a(t,"level2"),r(t,"footnotes")&&t.setAttribute("id","footnotes");m(n),v(n);var d=document.getElementsByClassName("citation"),l=document.getElementById("references");c(d,l);var s=document.getElementsByClassName("footnoteRef"),f=document.getElementById("footnotes");i(s,f)}}}}();window.addEventListener("load",function(){mindoc.main()})</script></body></html>